# パフォーマンスボトルネック最適化

## はじめに

SIP負荷試験ツールのパフォーマンスボトルネックを特定・解消するための最適化を実施しました。Go言語版と比較してパフォーマンスが劣っていた問題を改善するため、各レイヤーに対して段階的に最適化を行いました。

## 最適化領域

| 領域 | 問題 | 対策 |
|------|------|------|
| SIPパーサー | 毎回String/Vec<u8>をヒープ確保 | ゼロコピーパース、頻出ヘッダのインデックスキャッシュ |
| SIPフォーマッター | format!マクロ多用、バッファ未確保 | 事前確保バッファへの直接書き込み、`format_into` API追加 |
| トランスポート | 単一ソケット送信、バッファ毎回確保 | ラウンドロビン送信、スタック上バッファ使用 |
| 受信ループ | 100msポーリング | `tokio::select!`による非同期待機、複数ソケット並行受信 |
| プロキシ | 全メッセージ再シリアライズ | バッファ再利用、高速RNG（`rand::thread_rng`） |
| 統計収集 | `Mutex<Vec<Duration>>`によるロック競合 | シャーディングバッファ（CPUコア数ベース） |
| ダイアログ管理 | `all_call_ids()`で全エントリクローン | イテレータベース処理、`SmallRng`導入 |
| メッセージ構築 | format!マクロ多用 | 事前確保バッファへの直接書き込み |
| 非同期タスク | 個別tokio::spawn | BYEバッチ送信、動的CPS間隔調整 |

## 設計方針

- 後方互換性の維持: 既存のAPIシグネチャと動作を維持し、全既存テストが通過すること
- 段階的最適化: 各コンポーネントを独立して最適化可能にし、ベンチマークで効果を測定
- ゼロコスト抽象化の活用: Rustの所有権システムとライフタイムを活用
- TDDアプローチ: テストファーストで各最適化を実装

## 主要な変更点

### Headers構造体の拡張

頻出ヘッダ（Via, From, To, Call-ID, CSeq, Content-Length）へのインデックスキャッシュを追加し、`get()`で定数時間アクセスを実現。`SmallVec`を使用してViaヘッダのインデックスをスタック上に保持。

### トランスポート層

`UdpTransport`に`AtomicUsize`カウンタを追加し、`send_to`でラウンドロビンソケット選択を実装。受信バッファをスタック上の`[u8; 65535]`に変更。

### 統計収集

`Mutex<Vec<Duration>>`をCPUコア数ベースのシャーディングバッファに変更。パーセンタイル計算時に全シャードをマージ。

### 受信ループ

100msタイムアウトポーリングを`tokio::select!`に変更。複数ソケットの並行受信を実装。

### 非同期タスク管理

BYE送信を`tokio::time::interval`によるバッチ処理に変更。コール送信間隔をCPSベースの動的計算に変更。

## 正当性プロパティ

以下のプロパティをproptestで検証済み:

1. Format→Parseラウンドトリップ
2. ヘッダ検索のインデックスキャッシュ整合性
3. フォーマッター出力のバイト列一致
4. ラウンドロビン送信の均等性
5. プロキシリクエスト転送のVia/Record-Route正確性
6. Branch値の一意性
7. プロキシレスポンス転送のVia除去正確性
8. パーセンタイル計算の等価性
9. タイムアウト検出の正確性
10. 構築メッセージのパース可能性
11. ベンチマーク結果のJSONラウンドトリップ
